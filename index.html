<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Smooth Scratch Effect with SVG and GSAP</title>
    <style>
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            width: 100%;
            margin: 0; /* Ensure no default margins */
        }
        .scratch-container {
            position: relative; /* Important for absolute positioning of the SVG */
            display: inline-block; /* Fit to the text size */
        }
        a{
          font-size: 42px;
          color: black;
        }
        path {
            stroke: black;
            stroke-width: 6; /* Adjust thickness here */
            fill: none;
            stroke-linecap: round; /* Rounded corners for the lines */
        }
        svg {
            position: absolute; /* Position SVG over the link */
            top: 0!important; /* Align to the top of the link */
            left: 0!important; /* Align to the left of the link */
            pointer-events: none; /* Allows mouse events to pass through */
            width: 100%; /* Cover the entire text area */
            height: 100%; /* Cover the entire text area */
            opacity: 0; /* Start hidden */
            transition: opacity 0.2s ease-in; /* Smooth transition */
        }
    </style>
</head>
<body>
    <div class="scratch-container">
        <a href="#" id="scratchLink">Hover over me!</a>
        <svg id="scratchSVG"></svg> <!-- Initially hidden -->
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.11.5/gsap.min.js"></script>
    <script>
        const link = document.getElementById('scratchLink');
        const svg = document.getElementById('scratchSVG');
        let isHovering = false; // Track if mouse is hovering

        function setSVGSize() {
            const rect = link.getBoundingClientRect(); // Get the dimensions and position of the link
            svg.setAttribute('width', rect.width);
            svg.setAttribute('height', rect.height);
            svg.style.top = `${rect.top + window.scrollY}px`; // Correctly position SVG according to link's position
            svg.style.left = `${rect.left}px`; // Align to left
        }

        function generateScratchPath() {
            const points = [];
            const numPoints = 10; // Adjust the number of points for more or fewer lines
            const svgWidth = parseFloat(svg.getAttribute('width')); // Get SVG width
            const svgHeight = parseFloat(svg.getAttribute('height')); // Get SVG height

            // Starting point
            const startX = Math.random() * svgWidth;
            const startY = Math.random() * svgHeight;
            points.push(`${startX},${startY}`);

            for (let i = 0; i < numPoints; i++) {
                // Generate control points for curves
                const cpX = Math.random() * svgWidth; // Control point X
                const cpY = Math.random() * svgHeight; // Control point Y
                const endX = Math.random() * svgWidth; // End point X
                const endY = Math.random() * svgHeight; // End point Y

                // Create a quadratic Bezier curve
                points.push(`Q ${cpX} ${cpY}, ${endX} ${endY}`);
            }

            return `M ${points.join(' ')}`; // Creates a line path
        }

        function animateScratchEffect() {
            const pathData = generateScratchPath();
            const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
            path.setAttribute('d', pathData);
            path.setAttribute('stroke-linecap', 'round'); // Ensure rounded line caps
            path.setAttribute('stroke-width', '8'); // Set stroke width here
            svg.appendChild(path);

            // Use GSAP to animate the drawing of the path
            gsap.fromTo(path, {
                strokeDasharray: path.getTotalLength(),
                strokeDashoffset: path.getTotalLength()
            }, {
                strokeDashoffset: 0,
                duration: 1.5,
                ease: "power1.inOut",
                onComplete: () => {
                    // Optionally keep the path after drawing
                    // setTimeout(() => {
                    //     svg.removeChild(path);
                    // }, 500); // Adjust time before removing the path
                }
            });
        }

        link.addEventListener('mouseenter', () => {
            setSVGSize(); // Adjust SVG size and position
            svg.style.opacity = 0.5; // Show SVG on hover
            isHovering = true; // Set hovering to true
            animateScratchEffect(); // Start the animation on hover
        });

        link.addEventListener('mouseleave', () => {
            isHovering = false; // Set hovering to false
            // Optionally clear existing paths after a delay, but keep until fully outside
        });

        // Use mousemove to check if the mouse is still over the link
        link.addEventListener('mousemove', () => {
            isHovering = true; // Mouse is still over the link
        });

        // Use a timeout to remove the SVG when the mouse is completely outside the link
        setInterval(() => {
            if (!isHovering) {
                svg.style.opacity = 0; // Hide SVG when not hovering
                // Clear existing paths
                while (svg.firstChild) {
                    svg.removeChild(svg.firstChild);
                }
            }
        }, 100); // Check every 100 milliseconds

        window.addEventListener('resize', setSVGSize); // Resize the SVG on window resize
    </script>
</body>
</html>
